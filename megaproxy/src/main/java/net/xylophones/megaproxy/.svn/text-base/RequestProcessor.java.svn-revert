package net.xylophones.megaproxy;

import java.io.BufferedInputStream;
import java.io.InputStream;
import java.net.Socket;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.http.util.ByteArrayBuffer;

public class RequestProcessor implements Callable<Boolean> {
	
	private final Log log = LogFactory.getLog(RequestProcessor.class);
	
	private final Socket downstreamSocket;
	
	private static final int INPUT_BUFFER_SIZE = 256;
	
	private enum State {
		DOWNSTREAM_CONNECTED, 
		DOWNSTREAM_PROTOCOL_FETCHED, 
		DOWNSTREAM_HEADERS_FETCHED, 
		DOWNSTREAM_READ_COMPLETE, 
		UPSTREAM_CONNECTED,
		UPSTREAM_PROTOCOL_SENT,
		UPSTREAM_HEADERS_SENT,
		UPSTREAM_SEND_COMPLETE
	};
	
	private State state = State.DOWNSTREAM_CONNECTED;
	
	RequestInformation requestInfo = new RequestInformation();

	byte[] buffer = new byte[INPUT_BUFFER_SIZE];
	
	int bytesRead;

	public RequestProcessor(Socket socket) {
		this.downstreamSocket = socket;
	}

	/**
	 * TODO use ThreadLocal to allow each handler to get it's own instance of an InputStream
	 */
	@Override
	public Boolean call() throws Exception {
		
		/*
		 * variables for reading in downstream request data
		 */
		
		InputStream inputStream = downstreamSocket.getInputStream();
		BufferedInputStream bufferedInputStream = new BufferedInputStream(inputStream);
		ByteArrayBuffer inputBuffer = new ByteArrayBuffer(1024);
		List<String> headers = new ArrayList<String>(); 
		
		/*
		 * variables for writing request data upstream
		 */

		LineEndWatcher sectionWatcher = new LineEndWatcher();
		
		log.debug("Retreiving request");
		
		READ_LOOP:
		while ((bytesRead = bufferedInputStream.read(buffer)) != -1) {
			
			DATA_PROCESS_LOOP:
			for ( int i=0 ; i<bytesRead ; i++ ) {
				sectionWatcher.addByte(buffer[i]);
				
				if ( buffer[i] == '\n' ) {
					
					switch (state) {
						case DOWNSTREAM_CONNECTED:
							String requestLine = new String( inputBuffer.toByteArray() ).trim();
							if (log.isDebugEnabled()) {
								log.debug("Fetched request line from upstream: " + requestLine);
							}
							requestInfo.setRequestLine( requestLine );
							state = State.DOWNSTREAM_PROTOCOL_FETCHED;
							break;

						case DOWNSTREAM_PROTOCOL_FETCHED:
							if ( sectionWatcher.isHeaderSectionEnd() ) {
								requestInfo.setHeaders(headers);
								if (requestInfo.expectBody()) {
									state = State.DOWNSTREAM_HEADERS_FETCHED;
									log.debug("Headers section ended");
								} else {
									state = State.DOWNSTREAM_READ_COMPLETE;
									log.debug("Headers section ended - no body expected");
								}
							} else {
								String requestHeader = new String( inputBuffer.toByteArray() ).trim();
								headers.add( requestHeader );
								log.debug("Received header from upstream - " + requestHeader);
							}
							break;

						case DOWNSTREAM_HEADERS_FETCHED:
							if ( sectionWatcher.isBodySectionEnd() ) {
								requestInfo.setBody( inputBuffer.toByteArray() );
								state = State.DOWNSTREAM_READ_COMPLETE;
							}								
							break;
					}
					
					inputBuffer.clear();
				} else {
					inputBuffer.append( buffer, i, 1 );
				}
			} // DATA_PROCESS_LOOP

			if ( State.DOWNSTREAM_READ_COMPLETE == state ) {
				break;
			}
		} // READ_LOOP
		
		sectionWatcher = null;
		
		if (log.isDebugEnabled()) {
			log.debug("Retrieved request");
		}

		/*
		 * Write the request upstream
		 */
		
		/*
		downstreamSocket.getOutputStream().write( "HTTP/1.1 407 Proxy Authentication Required".getBytes() );
		downstreamSocket.getOutputStream().write( "\r\n".getBytes() );
		*/
		
		log.debug("Writing request");
		
		URL upstreamUrl = requestInfo.getUrl();
		int port = (upstreamUrl.getPort() > 0) ? upstreamUrl.getPort() : 80;
		Socket upstreamSocket = new Socket(upstreamUrl.getHost(), port);
		inputBuffer.clear();
		state = State.UPSTREAM_CONNECTED;
		
		upstreamSocket.getOutputStream().write(requestInfo.getRequestLine().getBytes());
		upstreamSocket.getOutputStream().write("\r\n".getBytes());
		log.debug("Sent request line upstream: " + new String( requestInfo.getRequestLine().getBytes() ));
		state = State.UPSTREAM_PROTOCOL_SENT;
		
		for (String header : requestInfo.getHeaders()) {
			upstreamSocket.getOutputStream().write(header.getBytes());
			upstreamSocket.getOutputStream().write("\r\n".getBytes());
			log.debug("Sent header upstream: " +new String(  header.getBytes() ));
		}
		upstreamSocket.getOutputStream().write("\r\n".getBytes());
		state = State.UPSTREAM_HEADERS_SENT;
		
		log.debug("Shutting down upstream output");
		upstreamSocket.shutdownOutput();
		
		upstreamSocket.setReceiveBufferSize(256);
		sectionWatcher = new LineEndWatcher();
		while ((bytesRead = upstreamSocket.getInputStream().read(buffer)) != -1) {
			for ( int i=0 ; i<bytesRead ; i++ ) {
				sectionWatcher.addByte(buffer[i]);
				if ( buffer[bytesRead-1] == '\n' ) {
					
				}
			}
			
			inputBuffer.append( buffer, 0, bytesRead );
			downstreamSocket.getOutputStream().write( inputBuffer.toByteArray() );
			inputBuffer.clear();
			log.debug("read " + bytesRead + " bytes from upstream");
		}
		
		log.debug("Sent response");

		/*
		 * Close the downstream socket - our work is done
		 */

		downstreamSocket.close();
		bufferedInputStream.close();

		return true;
	}
	
	private static class LineEndWatcher {
		
		byte[] bytes;
		
		int size;
		
		public LineEndWatcher() {
			this(4);
		}
		
		private LineEndWatcher(final int size) {
			bytes = new byte[size];
			this.size = size;
		}
		
		public void addByte(byte b) {
			for ( int i=1 ; i<size ; i++ ) {
				bytes[i-1] = bytes[i];
			}
			bytes[size-1] = b;
		}
		
		public void clear() {
			bytes = new byte[size];
		}
		
		public boolean isHeaderSectionEnd() {
			return (bytes[size-1] == '\n' && bytes[size-2] == '\n') 
			       || (
			    		   (bytes[size-1] == '\n' && bytes[size-2] == '\r') 
			    	    && (bytes[size-3] == '\n' && bytes[size-4] == '\r')
			       );
		}
		
		public boolean isBodySectionEnd() {
			return (bytes[size-1] == '\n' && bytes[size-2] == '\r');
		}
	}

}
