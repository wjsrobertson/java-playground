package net.xylophones.megaproxy;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;
import java.net.URL;
import java.util.concurrent.Callable;

import org.apache.commons.io.IOUtils;
import org.apache.http.Header;
import org.apache.http.HttpMessage;
import org.apache.http.HttpRequest;
import org.apache.http.HttpResponse;
import org.apache.http.message.BasicHeader;
import org.apache.http.util.ByteArrayBuffer;
import org.apache.log4j.Logger;

public class RequestProcessor implements Callable<Boolean> {
	
	private static final Logger log = Logger.getLogger(RequestProcessor.class);
	
	private final Socket downstreamSocket;
	
	private Connection upstreamConnection;
	
	private final boolean captureBody = false;
	
	private final ConnectionManager connectionManager = ConnectionManagerSource.getConnectionManager();

	public RequestProcessor(Socket socket) {
		this.downstreamSocket = socket;
	}
	
	@Override
	public Boolean call() throws Exception {
		try {
			processConnection();
			return true;
		} catch (IOException ieo) {
			return false;
		} finally {
			if ( downstreamSocket != null && downstreamSocket.isConnected() && ! downstreamSocket.isClosed()) {
				downstreamSocket.close();
			}
			if ( upstreamConnection != null ) {
				upstreamConnection.close();
			}
		}
	}
	
	/**
	 * Read an HTTP request from a client, send it to a server and return the
	 * server's response to the client
	 * 
	 * @return
	 * @throws IOException
	 */
	private void processConnection() throws IOException {
		HttpInputStream downInputStream = new HttpInputStream(
			new BufferedInputStream( downstreamSocket.getInputStream() )
		);
		
		HttpOutputStream downOutputStream = new HttpOutputStream(
				new BufferedOutputStream( downstreamSocket.getOutputStream() )
		);
		
		HttpOutputStream upOutputStream = null;
		HttpInputStream upInputStream = null;		
		
		boolean keepAliveDownStream = true;
		while (keepAliveDownStream) {
			
			HttpRequest httpRequest = (HttpRequest) downInputStream.readHttpMessage();
			cleanRequestForUpstream(httpRequest);
			URL url = new URL(httpRequest.getRequestLine().getUri());
			
			keepAliveDownStream = isProxyConnectionKeepAlive(httpRequest);
			
			log.debug("Retrieved request for: " + url);

			// Connect upstream if required
			
			upstreamConnection = getUpstreamConnection(url);
			upOutputStream = upstreamConnection.getOutputStream();
			upInputStream = upstreamConnection.getInputStream();

			// write request upstream
			
			upOutputStream.writeHttpMessage(httpRequest);
			upOutputStream.flush();
			
			// copy request body if there is one
			
			if (hasBody(httpRequest)) {
				log.debug("Request has body");

				if ( isTransferEncodingChunked(httpRequest) ) {
					log.debug("Copying chunked request body upstream");
					IOUtil.copyChunked(downInputStream, upOutputStream);
				} else {
					int contentLength = getContentLength(httpRequest);
					
					if ( contentLength >= 0 ) {
						log.debug("Copying " + contentLength + " bytes upstream");
						IOUtil.copy(downInputStream, upOutputStream, contentLength);
					} else {
						log.debug("Copying full request body upstream");
						IOUtils.copy(downInputStream, upOutputStream);
					}
				}
				
				downOutputStream.flush();
			}
			
			log.debug("Sent request");
	
			// read the headers from upstream response
	
			HttpResponse httpResponse = (HttpResponse) upInputStream.readHttpMessage();
			cleanResponseForDownStream(httpResponse);

			// write the response headers downstream
			
			downOutputStream.writeHttpMessage(httpResponse);
			downOutputStream.flush();
	
			// copy the response body downstream
			
			if (hasBody(httpResponse)) {
				log.debug("Response has body");
				
				if ( isTransferEncodingChunked(httpResponse) ) {
					log.debug("Copying chunked response body downstream");
					IOUtil.copyChunked(upInputStream, downOutputStream);
				} else {
					int contentLength = getContentLength(httpResponse);
					
					if ( contentLength >= 0 ) {
						log.debug("Copying " + contentLength + " bytes downstream");
						IOUtil.copy(upInputStream, downOutputStream, contentLength);
					} else {
						log.debug("Copying full response downstream");
						IOUtils.copy(upInputStream, downOutputStream);
					}					
				}

				downOutputStream.flush();
			}
			
			log.debug("Request/Response complete");
			
			if ( isConnectionClose(httpResponse) ) {
				log.debug("Closing upstream connection");
				upstreamConnection.close();
			}
			
			if ( isConnectionClose(httpRequest) || isProxyConnectionClose(httpRequest) ) {
				log.debug("Closing downstream connection");
				downstreamSocket.close();
			}
			
			//keepAliveDownStream = false;
		}
	}
	
	private Connection getUpstreamConnection(URL url) throws IOException  {
		return connectionManager.getConnection(url);
	}

	/**
	 * Alter headers of a client's http request to make them suitable for
	 * sending to a remote server
	 * 
	 * @param httpRequest
	 */
	private void cleanRequestForUpstream(HttpRequest httpRequest) {
		httpRequest.removeHeader( httpRequest.getFirstHeader("Proxy-Connection") );
		/*
		httpRequest.removeHeader( httpRequest.getFirstHeader("Connection") );
		httpRequest.removeHeader( httpRequest.getFirstHeader("Keep-Alive") );
		httpRequest.removeHeader( httpRequest.getFirstHeader("Proxy-Connection") );
		httpRequest.addHeader(new BasicHeader("Connection", "close"));
		*/
	}
	
	/**
	 * Alter headers of an HTTP response to make them suitable for returning
	 * to downstream client
	 * 
	 * @param httpResponse
	 */
	private void cleanResponseForDownStream(HttpResponse httpResponse) {
		/*
		httpResponse.removeHeader( httpResponse.getFirstHeader("Connection") );
		httpResponse.addHeader(new BasicHeader("Connection", "close"));
		httpResponse.addHeader(new BasicHeader("Proxy-Connection", "close"));
		*/
	}
	
	private int getContentLength(HttpMessage httpMessage) {
		Header contentLengthHeader = httpMessage.getFirstHeader("Content-Length");
		if (contentLengthHeader != null) {
			String contentLengthString = contentLengthHeader.getValue().trim();
			Integer contentLength = Integer.valueOf(contentLengthString);

			return contentLength;
		}
		
		return -1;
	}
	
	private boolean isTransferEncodingChunked(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Transfer-Encoding");
		
		if ( keepAliveHeader!=null ) {
			return "chunked".equals( keepAliveHeader.getValue().trim() );
		}
		
		return false;
	}
	
	private boolean isProxyConnectionKeepAlive(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Proxy-Connection");
		
		if ( keepAliveHeader!=null ) {
			return "keep-alive".equals( keepAliveHeader.getValue().trim() );
		}
		
		return false;
	}
	
	private boolean isProxyConnectionClose(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Proxy-Connection");
		
		if ( keepAliveHeader!=null ) {
			return "close".equals( keepAliveHeader.getValue().trim() );
		}
		
		return false;
	}

	private boolean isKeepAlive(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Keep-Alive");
		
		if ( keepAliveHeader!=null ) {
			return true;
		}
		
		return false;
	}
	
	private boolean isConnectionClose(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Connection");
		
		if ( keepAliveHeader!=null ) {
			return "close".equals( keepAliveHeader.getValue().trim() );
		}
		
		return false;
	}
	
	private boolean isConnectionKeepAlive(HttpMessage httpMessage) {
		Header keepAliveHeader = httpMessage.getFirstHeader("Connection");
		
		if ( keepAliveHeader!=null ) {
			return "keep-alive".equals( keepAliveHeader.getValue().trim() );
		}
		
		return false;
	}
	
	private void addConnectionClose(HttpMessage httpMessage) {
		httpMessage.removeHeader( httpMessage.getFirstHeader("Connection") );
		httpMessage.addHeader(new BasicHeader("Connection", "close"));
	}
	
	private void addConnectionKeepAlive(HttpMessage httpMessage) {
		httpMessage.removeHeader( httpMessage.getFirstHeader("Connection") );
		httpMessage.addHeader(new BasicHeader("Connection", "keep-alive"));
	}
	
	/**
	 * Check if an HTTP response or request will contain body data
	 * 
	 * @param httpMessage
	 * @return
	 */
	private boolean hasBody(HttpMessage httpMessage) {
		boolean hasBody = false;
		
		Header contentLengthHeader = httpMessage.getFirstHeader("Content-Length");
		if (contentLengthHeader != null) {
			String contentLengthString = contentLengthHeader.getValue().trim();
			Long contentLength = Long.valueOf(contentLengthString);
			
			if ( contentLength > 0 ) {
				hasBody = true;
			}
		} 
		
		Header contentTypeHeader = httpMessage.getFirstHeader("Content-Type");
		Header connectionHeader = httpMessage.getFirstHeader("Connection");
		if (contentTypeHeader != null && connectionHeader != null) {
			if (connectionHeader.equals("close")) {
				hasBody = true;
			}
		} 
		
		Header contentEncodingHeader = httpMessage.getFirstHeader("Transfer-Encoding");
		if (contentEncodingHeader != null) {
			String contentEncodingString = contentEncodingHeader.getValue().trim();

			if ( contentEncodingString.equals("chunked") ) {
				hasBody = true;
			}
		}

		return hasBody;
	}
}